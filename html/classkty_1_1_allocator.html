<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KittyInterpreter: kty::Allocator&lt; N, B &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">KittyInterpreter
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kty</b></li><li class="navelem"><a class="el" href="classkty_1_1_allocator.html">Allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkty_1_1_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kty::Allocator&lt; N, B &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that performs allocation and deallocation of memory. The memory pool is created on the stack to avoid heap fragmentation. Holds enough memory to allocate N instances of B bytes.  
 <a href="classkty_1_1_allocator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b8894f220a810e53c73fa8519f34961"><td class="memItemLeft" align="right" valign="top"><a id="a8b8894f220a810e53c73fa8519f34961"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#a8b8894f220a810e53c73fa8519f34961">Allocator</a> ()</td></tr>
<tr class="memdesc:a8b8894f220a810e53c73fa8519f34961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the allocator. <br /></td></tr>
<tr class="separator:a8b8894f220a810e53c73fa8519f34961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57162988e6375726c4047b114b38c8e6"><td class="memItemLeft" align="right" valign="top"><a id="a57162988e6375726c4047b114b38c8e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#a57162988e6375726c4047b114b38c8e6">stat</a> () const</td></tr>
<tr class="memdesc:a57162988e6375726c4047b114b38c8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints stats about the allocator. <br /></td></tr>
<tr class="separator:a57162988e6375726c4047b114b38c8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689bb98238d68adcfa0bee629b473380"><td class="memItemLeft" align="right" valign="top"><a id="a689bb98238d68adcfa0bee629b473380"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#a689bb98238d68adcfa0bee629b473380">reset_stat</a> ()</td></tr>
<tr class="memdesc:a689bb98238d68adcfa0bee629b473380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the stats about the allocator. <br /></td></tr>
<tr class="separator:a689bb98238d68adcfa0bee629b473380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4978f7b8b26258e292c8b21204b7425"><td class="memItemLeft" align="right" valign="top"><a id="ae4978f7b8b26258e292c8b21204b7425"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#ae4978f7b8b26258e292c8b21204b7425">dump_addresses</a> () const</td></tr>
<tr class="memdesc:ae4978f7b8b26258e292c8b21204b7425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the addresses used by the allocator. <br /></td></tr>
<tr class="separator:ae4978f7b8b26258e292c8b21204b7425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3279c07cc0ae623bf79685444dc6b84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3279c07cc0ae623bf79685444dc6b84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#aa3279c07cc0ae623bf79685444dc6b84">owns</a> (T *addr) const</td></tr>
<tr class="memdesc:aa3279c07cc0ae623bf79685444dc6b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an address is owned by this allocator.  <a href="#aa3279c07cc0ae623bf79685444dc6b84">More...</a><br /></td></tr>
<tr class="separator:aa3279c07cc0ae623bf79685444dc6b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96e96bf0293452b8541980945cedbb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#ad96e96bf0293452b8541980945cedbb0">available</a> () const</td></tr>
<tr class="memdesc:ad96e96bf0293452b8541980945cedbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the number of available blocks left in the pool.  <a href="#ad96e96bf0293452b8541980945cedbb0">More...</a><br /></td></tr>
<tr class="separator:ad96e96bf0293452b8541980945cedbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81cafe6792cf11ae8c655801d3822e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#ac81cafe6792cf11ae8c655801d3822e3">get_addr</a> (int const &amp;idx)</td></tr>
<tr class="memdesc:ac81cafe6792cf11ae8c655801d3822e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the memory at an index.  <a href="#ac81cafe6792cf11ae8c655801d3822e3">More...</a><br /></td></tr>
<tr class="separator:ac81cafe6792cf11ae8c655801d3822e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2125b69f017ef36542e7d94bb913ce2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2125b69f017ef36542e7d94bb913ce2a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#a2125b69f017ef36542e7d94bb913ce2a">get_idx</a> (T *addr)</td></tr>
<tr class="memdesc:a2125b69f017ef36542e7d94bb913ce2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index in the pool of a memory address.  <a href="#a2125b69f017ef36542e7d94bb913ce2a">More...</a><br /></td></tr>
<tr class="separator:a2125b69f017ef36542e7d94bb913ce2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6138e03234e741af27a5ff49667588c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6138e03234e741af27a5ff49667588c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#ae6138e03234e741af27a5ff49667588c">ref_count</a> (T *addr)</td></tr>
<tr class="memdesc:ae6138e03234e741af27a5ff49667588c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reference count of a memory address.  <a href="#ae6138e03234e741af27a5ff49667588c">More...</a><br /></td></tr>
<tr class="separator:ae6138e03234e741af27a5ff49667588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e199b71052a5728068fa744beaa6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a9e199b71052a5728068fa744beaa6e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#a7a9e199b71052a5728068fa744beaa6e">inc_ref_count</a> (T *addr)</td></tr>
<tr class="memdesc:a7a9e199b71052a5728068fa744beaa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases reference count of a memory address.  <a href="#a7a9e199b71052a5728068fa744beaa6e">More...</a><br /></td></tr>
<tr class="separator:a7a9e199b71052a5728068fa744beaa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ec908ff626c65d35bb9b5af0bc36d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6ec908ff626c65d35bb9b5af0bc36d9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#ac6ec908ff626c65d35bb9b5af0bc36d9">dec_ref_count</a> (T *addr)</td></tr>
<tr class="memdesc:ac6ec908ff626c65d35bb9b5af0bc36d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the reference count of a memory address. If this operation decreases the reference count to 0, it is not deallocated. To ensure that a decrease to 0 deallocates the address, call <a class="el" href="classkty_1_1_allocator.html#aae4b26c6c8df87c97cb204767c006d3c" title="Returns a single block of memory to the pool. This does not call the destructor on the data stored at...">deallocate()</a>.  <a href="#ac6ec908ff626c65d35bb9b5af0bc36d9">More...</a><br /></td></tr>
<tr class="separator:ac6ec908ff626c65d35bb9b5af0bc36d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd1b76519b259088bfe5e71e28d7454"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#a1dd1b76519b259088bfe5e71e28d7454">allocate</a> ()</td></tr>
<tr class="memdesc:a1dd1b76519b259088bfe5e71e28d7454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a single block of memory from the pool. Zeroes out memory before handing it out.  <a href="#a1dd1b76519b259088bfe5e71e28d7454">More...</a><br /></td></tr>
<tr class="separator:a1dd1b76519b259088bfe5e71e28d7454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4b26c6c8df87c97cb204767c006d3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae4b26c6c8df87c97cb204767c006d3c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classkty_1_1_allocator.html#aae4b26c6c8df87c97cb204767c006d3c">deallocate</a> (T *addr)</td></tr>
<tr class="memdesc:aae4b26c6c8df87c97cb204767c006d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single block of memory to the pool. This does not call the destructor on the data stored at the block. The destructor for the particular data type stored at the memory location should be called before deallocating the memory.  <a href="#aae4b26c6c8df87c97cb204767c006d3c">More...</a><br /></td></tr>
<tr class="separator:aae4b26c6c8df87c97cb204767c006d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt;<br />
class kty::Allocator&lt; N, B &gt;</h3>

<p>Class that performs allocation and deallocation of memory. The memory pool is created on the stack to avoid heap fragmentation. Holds enough memory to allocate N instances of B bytes. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3279c07cc0ae623bf79685444dc6b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3279c07cc0ae623bf79685444dc6b84">&#9670;&nbsp;</a></span>owns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::owns </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an address is owned by this allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the address is owned by this allocator, false otherwise. </dd></dl>

</div>
</div>
<a id="ad96e96bf0293452b8541980945cedbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96e96bf0293452b8541980945cedbb0">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the number of available blocks left in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of available blocks left in the pool. </dd></dl>

</div>
</div>
<a id="ac81cafe6792cf11ae8c655801d3822e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81cafe6792cf11ae8c655801d3822e3">&#9670;&nbsp;</a></span>get_addr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::get_addr </td>
          <td>(</td>
          <td class="paramtype">int const &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the address of the memory at an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the memory in the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the memory at that index. </dd></dl>

</div>
</div>
<a id="a2125b69f017ef36542e7d94bb913ce2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2125b69f017ef36542e7d94bb913ce2a">&#9670;&nbsp;</a></span>get_idx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::get_idx </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the index in the pool of a memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the memory address in the pool. </dd></dl>

</div>
</div>
<a id="ae6138e03234e741af27a5ff49667588c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6138e03234e741af27a5ff49667588c">&#9670;&nbsp;</a></span>ref_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::ref_count </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reference count of a memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of references to that address. If the address is invalid, -1 is returned. </dd></dl>

</div>
</div>
<a id="a7a9e199b71052a5728068fa744beaa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9e199b71052a5728068fa744beaa6e">&#9670;&nbsp;</a></span>inc_ref_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::inc_ref_count </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases reference count of a memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new reference count of the memory address. If the address is invalid, -1 is returned. </dd></dl>

</div>
</div>
<a id="ac6ec908ff626c65d35bb9b5af0bc36d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ec908ff626c65d35bb9b5af0bc36d9">&#9670;&nbsp;</a></span>dec_ref_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::dec_ref_count </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decreases the reference count of a memory address. If this operation decreases the reference count to 0, it is not deallocated. To ensure that a decrease to 0 deallocates the address, call <a class="el" href="classkty_1_1_allocator.html#aae4b26c6c8df87c97cb204767c006d3c" title="Returns a single block of memory to the pool. This does not call the destructor on the data stored at...">deallocate()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new reference count of the memory address. If the address is invalid, -1 is returned. </dd></dl>

</div>
</div>
<a id="a1dd1b76519b259088bfe5e71e28d7454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd1b76519b259088bfe5e71e28d7454">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a single block of memory from the pool. Zeroes out memory before handing it out. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a block of memory. If no memory is available, nullptr is returned. </dd></dl>

</div>
</div>
<a id="aae4b26c6c8df87c97cb204767c006d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4b26c6c8df87c97cb204767c006d3c">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N = Sizes::alloc_size, int B = Sizes::alloc_block_size&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classkty_1_1_allocator.html">kty::Allocator</a>&lt; N, B &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a single block of memory to the pool. This does not call the destructor on the data stored at the block. The destructor for the particular data type stored at the memory location should be called before deallocating the memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A pointer to a block of memory to be returned to the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the deallocation was successful, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>kty/containers/<a class="el" href="allocator_8hpp_source.html">allocator.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
